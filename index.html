<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pool Match</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better aesthetics */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
        }
        .card {
            background-color: #161b22; /* Slightly lighter dark card */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
        }
        .score-display {
            font-size: 4rem;
            line-height: 1;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .btn-action {
            transition: all 0.15s ease-in-out;
            transform: translateY(0);
        }
        .btn-action:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        /* Custom scrollbar for log */
        #matchLog::-webkit-scrollbar {
            width: 8px;
        }
        #matchLog::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        #matchLog::-webkit-scrollbar-track {
            background: #161b22;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#38bdf8', // Sky blue for primary actions
                        success: '#10b981', // Green for success
                        danger: '#ef4444', // Red for warnings/resets
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">

    <div id="appContainer" class="card p-6 rounded-xl w-full max-w-4xl text-white">
        <h1 class="text-3xl font-bold text-center mb-6 text-primary">Pool Match</h1>

        <!-- Connection Status Indicator -->
        <div id="statusMessage" class="text-center text-sm mb-4">
            Connecting...
        </div>

        <!-- Initial Setup Form -->
        <div id="setupView" class="space-y-4">
            <h2 class="text-xl font-semibold mb-3">Setup Match</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <input type="text" id="playerAInput" placeholder="Player A Name (e.g., John)" value="Player 1"
                       class="p-3 bg-gray-700 text-white rounded-lg focus:ring-primary focus:border-primary border-transparent border-2 transition">
                
                <input type="text" id="playerBInput" placeholder="Player B Name (e.g., Mike)" value="Player 2"
                       class="p-3 bg-gray-700 text-white rounded-lg focus:ring-primary focus:border-primary border-transparent border-2 transition">

                <input type="number" id="raceToInput" placeholder="Race To (e.g., 7)" value="7" min="1"
                       class="p-3 bg-gray-700 text-white rounded-lg focus:ring-primary focus:border-primary border-transparent border-2 transition">
            </div>

            <button id="startMatchButton" onclick="startMatch()"
                    class="btn-action w-full py-3 bg-primary hover:bg-sky-600 font-bold rounded-lg shadow-lg shadow-sky-900/50 transition">
                Start Match
            </button>
            <p class="text-sm text-gray-400 text-center mt-2">
                Match ID: <span id="matchIdDisplay" class="font-mono text-xs">Loading...</span>
            </p>
        </div>

        <!-- Active Scoreboard -->
        <div id="scoreboardView" class="hidden space-y-6">
            <div class="flex justify-between items-center text-center">
                
                <!-- Player A Card -->
                <div class="w-5/12 p-4 bg-gray-800 rounded-xl border-t-4 border-primary shadow-2xl">
                    <p id="playerADisplay" class="text-xl font-medium truncate text-primary">Player 1</p>
                    <div id="scoreADisplay" class="score-display text-primary mt-2">0</div>
                    <p class="text-gray-400 text-sm">Racks Won</p>
                </div>

                <div class="w-1/6 text-center text-4xl font-extrabold text-gray-500">
                    <span id="raceToDisplay">7</span>
                </div>

                <!-- Player B Card -->
                <div class="w-5/12 p-4 bg-gray-800 rounded-xl border-t-4 border-success shadow-2xl">
                    <p id="playerBDisplay" class="text-xl font-medium truncate text-success">Player 2</p>
                    <div id="scoreBDisplay" class="score-display text-success mt-2">0</div>
                    <p class="text-gray-400 text-sm">Racks Won</p>
                </div>
            </div>

            <!-- Action Buttons (Updated to 2x2 grid for Undo) -->
            <div id="actionButtons" class="grid grid-cols-2 gap-4">
                <button onclick="recordRackWin('A')"
                        class="btn-action py-3 bg-primary hover:bg-sky-600 font-extrabold text-lg rounded-xl shadow-md shadow-sky-900/50">
                    Player A Wins Rack
                </button>
                <button onclick="recordRackWin('B')"
                        class="btn-action py-3 bg-success hover:bg-emerald-600 font-extrabold text-lg rounded-xl shadow-md shadow-emerald-900/50">
                    Player B Wins Rack
                </button>
                <button onclick="reduceRackScore('A')"
                        class="btn-action py-3 bg-gray-600 hover:bg-gray-500 font-bold text-sm rounded-xl text-white">
                    Undo A (-1)
                </button>
                <button onclick="reduceRackScore('B')"
                        class="btn-action py-3 bg-gray-600 hover:bg-gray-500 font-bold text-sm rounded-xl text-white">
                    Undo B (-1)
                </button>
            </div>

            <!-- Match Log -->
            <div class="pt-4">
                <h3 class="text-lg font-semibold border-b border-gray-700 pb-2 mb-2">Match History</h3>
                <div id="matchLog" class="h-40 overflow-y-auto p-3 bg-gray-900 rounded-lg text-sm space-y-1">
                    <!-- Log entries will be inserted here -->
                </div>
            </div>

            <!-- Reset Button -->
            <button onclick="showResetDialog()"
                    class="btn-action w-full py-2 bg-gray-700 hover:bg-gray-600 text-danger font-medium rounded-lg transition mt-4">
                Reset Match
            </button>
        </div>
        
        <!-- Match Result Modal -->
        <div id="resultModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl text-center max-w-sm w-full border-t-8 border-yellow-400">
                <p class="text-4xl mb-4" id="modalEmoji">ðŸŽ‰</p>
                <h2 class="text-2xl font-bold mb-2 text-yellow-300">Match Concluded!</h2>
                <p id="modalWinnerText" class="text-xl mb-4"></p>
                <button onclick="resetMatch(true)" class="btn-action w-full py-3 bg-primary hover:bg-sky-600 font-bold rounded-lg transition">
                    Start New Match
                </button>
            </div>
        </div>

        <!-- Confirmation Dialog -->
        <div id="resetDialog" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl text-center max-w-sm w-full border-t-8 border-danger">
                <h2 class="text-xl font-bold mb-3 text-danger">Confirm Reset</h2>
                <p class="mb-4 text-gray-300">Are you sure you want to reset the current match? All scores will be lost.</p>
                <div class="flex justify-between gap-4">
                    <button onclick="resetMatch(false)" class="btn-action flex-1 py-2 bg-danger hover:bg-red-600 font-bold rounded-lg transition">
                        Yes, Reset
                    </button>
                    <button onclick="hideResetDialog()" class="btn-action flex-1 py-2 bg-gray-600 hover:bg-gray-500 font-medium rounded-lg transition">
                        Cancel
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, increment, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        let db;
        let auth;
        let userId = 'anonymous'; // Default
        let matchState = {
            playerA: 'Player 1',
            playerB: 'Player 2',
            scoreA: 0,
            scoreB: 0,
            raceTo: 7,
            status: 'Setup', // Setup, Active, Finished
            log: [],
            matchId: 'nineBallMatch_A' // Simple, fixed match ID for this single-file app
        };

        // --- Global Variables Access (Strict Environment Mode) ---
        // These variables MUST be provided by the hosting environment.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // This will cause an error if __firebase_config is not defined.
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}'); 
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        document.getElementById('matchIdDisplay').textContent = matchState.matchId;

        // --- Utility Functions (Exposed to global scope for HTML calls) ---
        window.startMatch = startMatch;
        window.recordRackWin = recordRackWin;
        window.reduceRackScore = reduceRackScore; // <-- New function exposed
        window.resetMatch = resetMatch;
        window.showResetDialog = showResetDialog;
        window.hideResetDialog = hideResetDialog;

        // --- Firebase Initialization and Auth ---

        async function initFirebase() {
            try {
                // Initialize app with config (will throw if firebaseConfig is invalid/empty)
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                
                userId = auth.currentUser?.uid || crypto.randomUUID();
                document.getElementById('statusMessage').textContent = 'Ready. User ID: ' + userId.substring(0, 8) + '...';
                
                // Start listening for match data
                loadMatch();

            } catch (error) {
                // This error will fire if firebaseConfig is missing or invalid.
                console.error("Firebase Initialization Error:", error);
                document.getElementById('statusMessage').textContent = 'Error: Firebase Config Missing/Invalid.';
                // Since connection failed, default to UI setup view for user input
                matchState.status = 'Setup';
                updateUI();
            }
        }

        function getMatchRef(matchId) {
            // Public data structure: /artifacts/{appId}/public/data/nine_ball_matches/{matchId}
            return doc(db, 'artifacts', appId, 'public', 'data', 'nine_ball_matches', matchId);
        }

        // --- Data Listener ---

        function loadMatch() {
            if (!db) return; // Skip if db failed to initialize
            
            const matchRef = getMatchRef(matchState.matchId);

            onSnapshot(matchRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    matchState = { ...matchState, ...data };
                    console.log("Match data updated:", matchState);
                    updateUI();
                } else {
                    // Match doesn't exist, ensure UI is in setup mode
                    matchState.status = 'Setup';
                    console.log("Match does not exist. Starting in setup mode.");
                    updateUI();
                }
            }, (error) => {
                console.error("Firestore Snapshot Error:", error);
                document.getElementById('statusMessage').textContent = 'Live Data Error!';
            });
        }
        
        // --- Core Match Functions ---
        
        async function startMatch() {
            if (!db) {
                alertUser('Cannot save data: Firebase is not connected.', 'danger');
                return;
            }

            const playerA = document.getElementById('playerAInput').value.trim() || 'Player 1';
            const playerB = document.getElementById('playerBInput').value.trim() || 'Player 2';
            const raceTo = parseInt(document.getElementById('raceToInput').value) || 7;

            if (raceTo < 1) {
                alertUser('Race to must be 1 or greater.', 'danger');
                return;
            }

            const initialData = {
                playerA: playerA,
                playerB: playerB,
                scoreA: 0,
                scoreB: 0,
                raceTo: raceTo,
                status: 'Active',
                log: [{ time: new Date().toLocaleTimeString(), message: `Match started: ${playerA} vs ${playerB} (Race to ${raceTo})` }]
            };

            try {
                const matchRef = getMatchRef(matchState.matchId);
                await setDoc(matchRef, initialData);
            } catch (e) {
                console.error("Error starting match: ", e);
            }
        }

        async function recordRackWin(winner) {
            if (!db || matchState.status !== 'Active') {
                alertUser('Cannot record win: Firebase is not connected or match is finished.', 'danger');
                return;
            }
            
            const isPlayerAWin = winner === 'A';
            const playerKey = isPlayerAWin ? 'playerA' : 'playerB';
            const scoreKey = isPlayerAWin ? 'scoreA' : 'scoreB';
            const playerName = matchState[playerKey];
            const newScore = matchState[scoreKey] + 1;
            
            const logEntry = { 
                time: new Date().toLocaleTimeString(), 
                message: `${playerName} wins Rack ${newScore}. Score is now ${isPlayerAWin ? newScore : matchState.scoreA} - ${!isPlayerAWin ? newScore : matchState.scoreB}.` 
            };
            
            const updatePayload = {
                [scoreKey]: increment(1),
                log: [...matchState.log, logEntry]
            };

            let newStatus = 'Active';

            // Check for match end
            if (newScore >= matchState.raceTo) {
                newStatus = 'Finished';
                const finalLogEntry = { 
                    time: new Date().toLocaleTimeString(), 
                    message: `${playerName} wins the match! Final Score: ${isPlayerAWin ? newScore : matchState.scoreA} - ${!isPlayerAWin ? newScore : matchState.scoreB}.`
                };
                updatePayload.status = newStatus;
                updatePayload.log.push(finalLogEntry);
            }
            
            try {
                const matchRef = getMatchRef(matchState.matchId);
                // Use updateDoc to apply the increment atomically
                await updateDoc(matchRef, updatePayload); 

            } catch (e) {
                console.error("Error recording rack win: ", e);
            }
        }
        
        // Function to reduce a player's score
        async function reduceRackScore(player) {
            if (!db) {
                 alertUser('Cannot undo: Firebase is not connected.', 'danger');
                 return;
            }
            
            const isPlayerA = player === 'A';
            const playerKey = isPlayerA ? 'playerA' : 'playerB';
            const scoreKey = isPlayerA ? 'scoreA' : 'scoreB';
            const playerName = matchState[playerKey];
            const currentScore = matchState[scoreKey];
            
            if (currentScore <= 0) {
                alertUser(`${playerName}'s score is already zero. Cannot undo.`, 'danger');
                return;
            }

            const newScore = currentScore - 1;
            
            const logEntry = { 
                time: new Date().toLocaleTimeString(), 
                message: `UNDO: Reduced ${playerName}'s score to ${newScore}. Score is now ${isPlayerA ? newScore : matchState.scoreA} - ${!isPlayerA ? newScore : matchState.scoreB}.` 
            };
            
            const updatePayload = {
                [scoreKey]: increment(-1),
                log: [...matchState.log, logEntry]
            };

            // If the match was finished, reducing the score means it might be active again
            if (matchState.status === 'Finished') {
                // If the reduction drops the score below the raceTo, change status back to Active
                if (currentScore === matchState.raceTo) {
                    updatePayload.status = 'Active';
                    const revertLogEntry = {
                        time: new Date().toLocaleTimeString(),
                        message: `Match status reverted to Active due to score change.`
                    };
                    updatePayload.log.push(revertLogEntry);
                }
            }
            
            try {
                const matchRef = getMatchRef(matchState.matchId);
                await updateDoc(matchRef, updatePayload); 

            } catch (e) {
                console.error("Error reducing rack score: ", e);
            }
        }


        // Resets the match state in Firestore
        async function resetMatch(startNew = false) {
            hideResetDialog();

            if (!db) {
                alertUser('Cannot reset match: Firebase is not connected.', 'danger');
                return;
            }

            const resetData = {
                playerA: matchState.playerA,
                playerB: matchState.playerB,
                scoreA: 0,
                scoreB: 0,
                raceTo: matchState.raceTo,
                status: 'Setup',
                log: [{ time: new Date().toLocaleTimeString(), message: 'Match has been reset.' }]
            };
            
            try {
                const matchRef = getMatchRef(matchState.matchId);
                await setDoc(matchRef, resetData);
                
                if (startNew) {
                    // Automatically transition to setup view after reset
                    document.getElementById('setupView').classList.remove('hidden');
                    document.getElementById('scoreboardView').classList.add('hidden');
                    document.getElementById('resultModal').classList.add('hidden');
                }

            } catch (e) {
                console.error("Error resetting match: ", e);
            }
        }


        // --- UI Rendering ---

        function updateUI() {
            // Update inputs with current names/race to (useful after load/reset)
            document.getElementById('playerAInput').value = matchState.playerA;
            document.getElementById('playerBInput').value = matchState.playerB;
            document.getElementById('raceToInput').value = matchState.raceTo;

            // Update scoreboard displays
            document.getElementById('playerADisplay').textContent = matchState.playerA;
            document.getElementById('playerBDisplay').textContent = matchState.playerB;
            document.getElementById('scoreADisplay').textContent = matchState.scoreA;
            document.getElementById('scoreBDisplay').textContent = matchState.scoreB;
            document.getElementById('raceToDisplay').textContent = matchState.raceTo;
            
            // Render Log
            const logElement = document.getElementById('matchLog');
            logElement.innerHTML = matchState.log.map(entry => {
                return `<p class="text-xs text-gray-300"><span class="font-mono text-gray-500 mr-2">[${entry.time}]</span> ${entry.message}</p>`;
            }).reverse().join(''); // Reverse to show latest at the top
            
            // Toggle Views based on status
            const setupView = document.getElementById('setupView');
            const scoreboardView = document.getElementById('scoreboardView');
            const actionButtons = document.getElementById('actionButtons');
            const resultModal = document.getElementById('resultModal');

            setupView.classList.toggle('hidden', matchState.status !== 'Setup');
            scoreboardView.classList.toggle('hidden', matchState.status === 'Setup');
            actionButtons.classList.toggle('hidden', matchState.status === 'Finished');

            // Handle Finished Status
            if (matchState.status === 'Finished') {
                resultModal.classList.remove('hidden');
                
                const winnerName = matchState.scoreA >= matchState.raceTo ? matchState.playerA : matchState.playerB;
                const finalScore = `${matchState.scoreA} - ${matchState.scoreB}`;
                
                document.getElementById('modalWinnerText').textContent = `${winnerName} is the champion with a final score of ${finalScore}!`;
            } else {
                resultModal.classList.add('hidden');
            }
        }

        // --- Dialogs/Modals ---

        function showResetDialog() {
            document.getElementById('resetDialog').classList.remove('hidden');
        }

        function hideResetDialog() {
            document.getElementById('resetDialog').classList.add('hidden');
        }

        function alertUser(message, type) {
            // Simple visual feedback instead of alert()
            const statusDiv = document.getElementById('statusMessage');
            const originalText = statusDiv.textContent;
            
            // Temporarily set a specific background for visibility
            statusDiv.style.backgroundColor = type === 'danger' ? '#ef444433' : '#38bdf833';
            statusDiv.style.borderRadius = '0.5rem';
            statusDiv.style.padding = '0.5rem';
            
            statusDiv.textContent = message;
            statusDiv.classList.add(`text-${type}-400`);
            
            setTimeout(() => {
                // Restore original text
                statusDiv.textContent = originalText;
                statusDiv.classList.remove(`text-${type}-400`);
                statusDiv.style.backgroundColor = 'transparent';
                statusDiv.style.padding = '0';
            }, 3000);
        }

        // Initialize Firebase on load
        window.onload = initFirebase;
    </script>
</script>